import networkx as nx
import random
import matplotlib.pyplot as plt
import math

def generate_synthetic_large_graph(num_nodes, num_edges, num_timestamps):
    G = nx.Graph()

    # Add nodes with fixed weights
    for i in range(num_nodes):
        G.add_node(i, weight=round(random.uniform(0.5, 2.0), 2))  # Node weights vary between 0.5 and 2.0
        if i % 10000 == 0:
            print(f"Added {i} nodes...")

    # Add edges with base weights based on connected node weights
    for i in range(num_edges):
        u = random.randint(0, num_nodes - 1)
        v = random.randint(0, num_nodes - 1)
        if u!= v and not G.has_edge(u, v):
            node_u_weight = G.nodes[u]['weight']
            node_v_weight = G.nodes[v]['weight']
            # Use the weighted geometric mean as the base weight
            base_weight = round(node_u_weight * node_v_weight, 2)
            G.add_edge(u, v, base_weight=base_weight, length=round(random.uniform(1, 10), 2))
        if G.degree(u) > 4:
            G.remove_edge(u, v)
        if G.degree(v) > 4:
            G.remove_edge(u, v)
        if i % 10000 == 0:
            print(f"Added {i} edges...")

    # Vary edge weights according to timestamp
    for t in range(num_timestamps):
        for u, v in G.edges():
            base_weight = G[u][v]['base_weight']
            weight_variation = round(random.uniform(0.8, 1.2), 2)
            G[u][v][t] = round(base_weight * weight_variation, 2)

    return G

G = generate_synthetic_large_graph(50, 300, 10)

def community_detection_by_edge_length(G, weight_attribute='length'):
    # Create a copy of the graph to avoid modifying the original graph
    G_copy = G.copy()

    # Normalize edge weights to ensure they are between 0 and 1
    max_weight = max(G_copy.edges(data=True), key=lambda x: x[2][weight_attribute])[2][weight_attribute]
    for u, v, d in G_copy.edges(data=True):
        d[weight_attribute] /= max_weight

    # Perform community detection using the Louvain algorithm
    communities = nx.algorithms.community.louvain_communities(G_copy, weight=weight_attribute)

    # Convert the communities to a list of node-community assignments
    community_assignments = []
    for community in communities:
        for node in community:
            community_assignments.append(list(community).index(node))

    return community_assignments

def visualize_communities(G, communities):
    # Assign a random color to each community
    colors = [random.randint(0, 255) for _ in set(communities)]

    # Create a list of node colors
    node_colors = [colors[community] for community in communities]

    # Draw the graph with node colors
    nx.draw(G, node_color=node_colors, cmap=plt.cm.rainbow, with_labels=True)
    plt.show(block=True)

# Perform community detection on the graph
communities = community_detection_by_edge_length(G)

# Visualize the communities
visualize_communities(G, communities)
